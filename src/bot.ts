import { TwitterApi, TweetV2, Tweetv2SearchResult, UserV2 } from 'twitter-api-v2';
import { HfInference } from '@huggingface/inference';
import * as schedule from 'node-schedule';
import axios from 'axios';
import * as dotenv from 'dotenv';
import { logger } from './utils/logger';

// Load environment variables
dotenv.config();

// Twitter API client setup
const client = new TwitterApi({
  appKey: process.env.TWITTER_API_KEY!,
  appSecret: process.env.TWITTER_API_SECRET!,
  accessToken: process.env.TWITTER_ACCESS_TOKEN!,
  accessSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET!,
});

// Initialize Mistral LLM

// Sample prompts for tweet generation
const prompts: string[] = [
  'Write a witty tweet about trending tech news.',
  'Create a fun fact tweet about AI advancements.',
  'Generate an engaging tweet about social media marketing.',
  'Share an interesting insight about digital transformation.',
  'Write a tweet about the future of technology.',
];

// News topic configuration
export let currentNewsTopic = '#news OR #breakingnews';

export function setNewsTopic(topic: string): void {
  currentNewsTopic = topic;
  logger.info(`News topic updated to: ${topic}`);
}

// Function to fetch news headlines
async function fetchNews(): Promise<string[]> {
  try {
    // Search for recent news tweets from verified accounts
    const tweets = await client.v2.search(currentNewsTopic, {
      'tweet.fields': ['created_at', 'public_metrics'],
      'user.fields': ['verified'],
      max_results: 10,
      'expansions': ['author_id'],
    });

    // Convert the response to an array of tweets
    const tweetsArray = Array.isArray(tweets.data) ? tweets.data : [];
    
    if (tweetsArray.length === 0) {
      console.log('No news tweets found');
      return [];
    }

    // Filter for verified accounts and get the most recent tweets
    const newsTweets = tweetsArray
      .filter((tweet: TweetV2) => {
        const author = tweets.includes?.users?.find((user: UserV2) => user.id === tweet.author_id);
        return author?.verified;
      })
      .map((tweet: TweetV2) => tweet.text);

    console.log(`Successfully fetched ${newsTweets.length} news tweets`);
    return newsTweets;
  } catch (error: any) {
    // Enhanced error logging
    if (error.data) {
      // Twitter API error response
      console.error('Twitter API Error:', {
        status: error.data.status,
        error: error.data.error,
        details: error.data.detail,
        title: error.data.title,
        type: error.data.type
      });
    } else if (error.errors) {
      // Alternative Twitter error format
      console.error('Twitter API Errors:', error.errors);
    } else if (error.message) {
      console.error('Error Details:', error.message);
    }

    // Check if credentials are present
    const credentials = {
      hasApiKey: !!process.env.TWITTER_API_KEY,
      hasApiSecret: !!process.env.TWITTER_API_SECRET,
      hasAccessToken: !!process.env.TWITTER_ACCESS_TOKEN,
      hasAccessSecret: !!process.env.TWITTER_ACCESS_TOKEN_SECRET
    };
    console.error('Credentials Status:', credentials);

    return [];
  }
}

// Replace pipeline usage in generateTweet with HfInference
const hf = new HfInference(process.env.HUGGINGFACE_TOKEN);

export async function generateTweet(prompt: string): Promise<string> {
  try {
    // Use the text-generation endpoint
    const response = await hf.textGeneration({
      model: 'mistralai/Mistral-7B-Instruct-v0.1',
      inputs: `<s>[INST] ${prompt} [/INST]`,
      parameters: {
        max_new_tokens: 80,
        temperature: 0.7,
        top_p: 0.95,
        repetition_penalty: 1.2,
      },
    });
    const generated = (response as any).generated_text;
    if (!generated || typeof generated !== 'string' || !generated.trim()) {
      throw new Error('No text generated by the model.');
    }
    return generated.trim().slice(0, 280);
  } catch (error) {
    console.error('Error generating tweet:', error);
    throw new Error('Tweet generation failed.');
  }
}

// Add this function to verify permissions
async function verifyTwitterPermissions(): Promise<void> {
  try {
    // First try to get user info to verify basic authentication
    logger.info('Attempting to verify user credentials...');
    const user = await client.v2.me();
    logger.info('Successfully authenticated as user:', user.data.username);

    // Try to get detailed permissions
    try {
      const response = await client.v2.get('users/me');
      // Safely check headers
      const headers = response?._headers;
      const accessLevel = headers ? headers.get('x-access-level') : null;
      
      logger.info('Twitter API Permissions:', {
        username: user.data.username,
        accessLevel: accessLevel || 'unknown',
        canRead: accessLevel?.includes('read'),
        canWrite: accessLevel?.includes('write'),
        canDM: accessLevel?.includes('directmessages'),
      });
      
      if (!accessLevel?.includes('write')) {
        throw new Error('Write permission is not enabled. Please update your app permissions to "Read and Write".');
      }
    } catch (error: any) {
      // If we can't get headers but user auth worked, log a warning but don't fail
      logger.warn('Could not verify detailed permissions, but basic authentication succeeded', {
        error: error.message
      });
      
      // Try an alternative method to verify write access
      logger.info('Attempting to verify write access through alternative method...');
      try {
        // Try to get app settings which requires write access
        await client.v2.get('users/me/pinned_lists');
        logger.info('Write access verified through alternative method');
      } catch (error: any) {
        logger.error('Failed to verify write access:', error.message);
        throw new Error('Could not verify write permissions. Please check your app permissions in the Twitter Developer Portal.');
      }
    }
  } catch (error: any) {
    if (error.data?.errors) {
      logger.error('Twitter API Error:', error.data.errors);
    } else {
      logger.error('Permission verification failed:', error.message);
    }
    throw error;
  }
}

// Modify the generateAndPostTweet function to include permission check
async function generateAndPostTweet(): Promise<void> {
  try {
    // First verify permissions
    logger.info('Verifying Twitter API permissions...');
    await verifyTwitterPermissions();
    
    const prompt = prompts[Math.floor(Math.random() * prompts.length)];
    let finalPrompt = prompt;
    
    try {
      const news = await fetchNews();
      if (news.length > 0) {
        finalPrompt = `${prompt} Context: ${news[Math.floor(Math.random() * news.length)]}`;
      }
    } catch (error) {
      logger.error('Error fetching news, continuing without news context:', error);
    }

    const tweet = await generateTweet(finalPrompt);
    await client.v2.tweet(tweet);
    logger.info(`Posted tweet: ${tweet}`);
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.includes('Write permission')) {
        logger.error('Permission Error:', error.message);
        logger.error('Please update your app permissions in the Twitter Developer Portal and regenerate your tokens.');
      } else {
        logger.error('Error in generateAndPostTweet:', error);
      }
    } else {
      logger.error('Unknown error in generateAndPostTweet:', error);
    }
    throw error;
  }
}

// Schedule tweets
function scheduleTweets(): void {
  const intervalHours = parseInt(process.env.TWEET_INTERVAL_HOURS || '4');
  const scheduleRule = `0 */${intervalHours} * * *`;
  
  schedule.scheduleJob(scheduleRule, generateAndPostTweet);
  logger.info(`Scheduled tweets every ${intervalHours} hours`);
}

// Start the bot
async function startBot(): Promise<void> {
  try {
    logger.info('Starting Twitter bot...');
    scheduleTweets();
    logger.info('Twitter bot is running...');
  } catch (error) {
    logger.error('Error starting bot:', error);
    process.exit(1);
  }
}

// Export functions for testing
export {
  generateAndPostTweet,
  fetchNews,
  startBot,
}; 